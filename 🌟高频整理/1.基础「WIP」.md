## TCP三次握手/四次挥手
##### 三次握手
TCP是面向连接的，因此通信双方在发送数据前，需要建立一条连接。
在TCP/IP协议中，TCP协议提供可靠的连接服务，连接的建立需要通过**三次握手**进行初始化。

- 第一次握手：C主动向S发送SYN包，发起连接请求，C进入同步已发送状态，等待S确认；
- 第二次握手：S收到C发来的SYN包，向C回复ACK，并向C发送SYN包，S进入同步已接收状态；
- 第三次握手：C收到S发来的ACK，确认S已收到同步请求，并回复S的SYN包，向S发送ACK，C进入连接已建立状态；S收到C的ACK后，也进入连接已建立状态。
##### 四次挥手
四次挥手保证通信双方正常关闭一次TCP连接。

- 第一次挥手：C主动向S发送FIN包，发起关闭连接请求，C进入终止等待1状态；
- 第二次挥手：S收到C发来的FIN包，向C回复ACK确认，进入终止等待状态，此后，S可以继续向C发送剩余数据；
- 第三次挥手：S发送完剩余数据后，向C发送FIN包，进入最后确认状态；
- 第四次挥手：C向S回复ACK，进入超时等待状态，等待2MSL后，关闭连接，S收到ACK后直接关闭连接。
## DOM事件

1. DOM0级事件：`dom.onclick = function () {}`。后面绑定的事件会覆盖前面的，无法对事件行为做出配置；
2. DOM2级事件：`dom.addEventListener('click', function(){}, { /* options */ })`
   1. 事件发生后，会从DOM树的顶层开始向目标元素传递（捕获），之后再从目标元素向顶层传递（... -> body -> html -> document -> window）
   2. 分为三个阶段：事件捕获，处于目标，事件冒泡；
   3. 第三个参数：可以为布尔值，false：冒泡触发；true：捕获触发；也可以为对象，传入配置项；
   4. 事件对象Event中属性eventPhase表示事件所处阶段：0：没有事件被处理 | 1：捕获 | 2：处于目标 | 3：冒泡
3. 事件委托：在上层元素上绑定一个事件，利用冒泡，在顶层捕获内部元素的事件，进行响应。好处：内部元素多（li）的时候，不用多次获取DOM，提高性能节省代码量。 
## 事件循环
> 为了防止多线程操作，导致DOM不一致，而且JS本身为简单的脚本语言，所以JS被设计成是单线程的。

在单线程中，为了实现异步任务，所以设计了事件循环机制。
不同的异步事件本身，由对应的线程去实现（如计时器线程、网络线程等），事件完成的JS回调函数，通过事件循环机制执行。
事件循环的实现借助两种类型的队列：宏任务队列、微任务队列。
在JS同步代码执行过程中，会将异步任务放入上述两种队列中，同步代码执行完成后，当异步任务的触发时机到达，JS会从队列中取出响应的异步任务来执行。
其中，宏任务队列的优先级较低，用来存放setTimeout、ajax等；微任务队列存放Promise等优先级较高的任务。事件循环过程中，每个宏任务执行之前，都会清空一次微任务队列。
> 微任务的设计的目的：由于宏任务什么时候触发是由浏览器控制的，开发者没有办法精确的控制，所以JS实现了一种可控性更强，优先级更高的微任务。

## AJAX
直译：异步的JS和XML，不需要重载整个网页，与服务器交换数据，更新局部数据。
原理：通过XmlHttpRequest（xhr）对象，向服务器发送**异步**请求，然后用JS来操作DOM更新页面。
## 跨域
浏览器同源策略：URL由 协议、IP、端口组成，任何一个不一样，都属于不同源。当网页去访问一个不同源的资源时，就会发生跨域。发生跨域后，三种行为收到限制：

- AJAX请求无效；
- DOM无法操作；
- Cookie无法操作；

解决跨域问题：

- JSONP：script标签不受跨域限制
   - 可以定一个一个方法：`function a(res) {/* ... */}`;
   - 在script的src中，将函数名作为参数，传递给服务端：`<script src="http://1.1.1.1:1234?callback=a" />`；
   - 服务端收到后，将数据和函数名拼成一条js语句返回：`res.send(a+'(res)')`；
   - 返回后，script会执行`a(res)`，实现函数功能；
- CORS：跨域资源共享，是一个标准，新增了一组HTTP标头，允许服务器声明，哪些源站通过浏览器有权访问哪些资源。浏览器会首先通过OPTIONS方法发起一个预检请求，获知服务器是否允许该跨域请求，服务器通过这个请求也可以告知客户端，是否需要携带身份凭证（Cookie等）。
   - 响应头：
      - Access-Control-Allow-Origin：允许访问该资源的站点，通配符*表示无限制，都可以访问；
      - Access-Control-Allow-Header：用于响应预检请求，指明实际请求中需要携带的标头字段；
      - Access-Control-Allow-Methods：用于响应预检请求，指明哪些方法可以访问该资源；
   - 请求头：
      - origin：请求的源站点；
      - Access-Control-Request-Header：用于预检请求，告知服务器实际请求携带的标头字段；
      - Access-Control-Request-Methods：用于预检请求，告知服务器实际请求的方法；
## SPA/SEO
SPA（Single-page application，单页应用）是只加载一个单独网页的 web 应用实现，当需要显示不同的内容时，它通过 JavaScript API（例如 XMLHttpRequest 和 Fetch）更新主体内容。
SEO（搜索引擎优化）是一种让网站在搜索引擎结果中更加清晰，也帮助我们将搜索结果更靠前。搜索引擎通过爬虫抓取网页，定位网页内容，为用户展示更相关的搜索结果。
**SPA对SEO不友好**：爬虫只能获取静态页面，无法执行JS。而SPA在初始阶段只会返回页面的基础结构，后续的内容都是通过JS动态获取的，这样很不利于爬虫对网站后续内容的收录。
解决方案：SSR。
## 大数据渲染怎么做
## XSS、XSRF
